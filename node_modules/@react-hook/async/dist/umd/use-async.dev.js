(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.UseAsync = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var useLatest = function useLatest(current) {
    var storedValue = React.useRef(current);
    storedValue.current = current;
    return storedValue;
  };

  function _ref(prev, action) {
    return {
      // This is the current status of the promise or async/await function. A
      // promise or async/await can only be in one state at a time.
      status: action.status,
      // The value is persisted between 'success' statuses. This means I can
      // still display things that depend on my current value while my new
      // value is loading.
      value: action.status === 'success' ? action.value : prev.value,
      // Errors get reset each time we leave the error state. There's really
      // no use in keeping those around. They go stale once we leave.
      error: action.status === 'error' ? action.error : void 0
    };
  }

  function _ref2() {
    return {
      status: 'idle',
      value: void 0,
      error: void 0
    };
  }

  function useAsync(asyncCallback) {
    var _React$useReducer = React.useReducer(_ref, void 0, _ref2),
        state = _React$useReducer[0],
        dispatch = _React$useReducer[1]; // Creates a stable callback that manages our loading/success/error status updates
    // as the callback is invoked.


    var storedCallback = useLatest(asyncCallback);

    var _React$useState = React.useState(function () {
      var cancelled = new Set();
      var previous;
      return _extends( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var current,
            value,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Reloading automatically cancels previous promises
                cancelled.add(previous);
                dispatch({
                  status: 'loading'
                });
                current = null;
                _context.prev = 3;
                previous = current = storedCallback.current.apply(storedCallback, _args);
                _context.next = 7;
                return current;

              case 7:
                value = _context.sent;
                !cancelled.has(current) && dispatch({
                  status: 'success',
                  value: value
                });
                _context.next = 14;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](3);
                current && !cancelled.has(current) && dispatch({
                  status: 'error',
                  error: _context.t0
                });

              case 14:
                _context.prev = 14;
                cancelled.delete(current);
                return _context.finish(14);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 11, 14, 17]]);
      })), {
        cancel: function cancel() {
          cancelled.add(previous);
        }
      });
    }),
        callback = _React$useState[0]; // Cancels any pending async callbacks when the hook unmounts


    React.useEffect(function () {
      return callback.cancel;
    }, [callback]);

    function _cancel() {
      // Prevent the callback from dispatching
      callback.cancel(); // Create a new callback and set status to cancelled

      dispatch({
        status: 'cancelled'
      });
    }

    return [React.useMemo(function () {
      return {
        status: state.status,
        value: state.value,
        error: state.error,
        cancel: _cancel
      };
    }, [callback, state]), callback];
  }
  function useAsyncEffect(asyncCallback, dependencies) {
    var _useAsync = useAsync(asyncCallback),
        state = _useAsync[0],
        callback = _useAsync[1]; // Runs the callback each time deps change


    React.useEffect(function () {
      callback(); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
    return state;
  }

  exports.useAsync = useAsync;
  exports.useAsyncEffect = useAsyncEffect;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=use-async.dev.js.map
