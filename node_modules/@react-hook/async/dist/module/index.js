import * as React from 'react';
import useLatest from '@react-hook/latest';

function _ref(prev, action) {
  return {
    // This is the current status of the promise or async/await function. A
    // promise or async/await can only be in one state at a time.
    status: action.status,
    // The value is persisted between 'success' statuses. This means I can
    // still display things that depend on my current value while my new
    // value is loading.
    value: action.status === 'success' ? action.value : prev.value,
    // Errors get reset each time we leave the error state. There's really
    // no use in keeping those around. They go stale once we leave.
    error: action.status === 'error' ? action.error : void 0
  };
}

function _ref2() {
  return {
    status: 'idle',
    value: void 0,
    error: void 0
  };
}

export function useAsync(asyncCallback) {
  const [state, dispatch] = React.useReducer(_ref, void 0, _ref2); // Creates a stable callback that manages our loading/success/error status updates
  // as the callback is invoked.

  const storedCallback = useLatest(asyncCallback);
  const [callback] = React.useState(() => {
    const cancelled = new Set();
    let previous;
    return Object.assign(async (...args) => {
      // Reloading automatically cancels previous promises
      cancelled.add(previous);
      dispatch({
        status: 'loading'
      });
      let current = null;

      try {
        previous = current = storedCallback.current(...args);
        const value = await current;
        !cancelled.has(current) && dispatch({
          status: 'success',
          value
        });
      } catch (error) {
        current && !cancelled.has(current) && dispatch({
          status: 'error',
          error
        });
      } finally {
        cancelled.delete(current);
      }
    }, {
      cancel: () => {
        cancelled.add(previous);
      }
    });
  }); // Cancels any pending async callbacks when the hook unmounts

  React.useEffect(() => callback.cancel, [callback]);

  function _ref3() {
    // Prevent the callback from dispatching
    callback.cancel(); // Create a new callback and set status to cancelled

    dispatch({
      status: 'cancelled'
    });
  }

  return [React.useMemo(() => {
    return {
      status: state.status,
      value: state.value,
      error: state.error,
      cancel: _ref3
    };
  }, [callback, state]), callback];
}
export function useAsyncEffect(asyncCallback, dependencies) {
  const [state, callback] = useAsync(asyncCallback); // Runs the callback each time deps change

  React.useEffect(() => {
    callback(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, dependencies);
  return state;
}