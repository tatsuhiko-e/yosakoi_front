"use strict";

exports.__esModule = true;
exports.useAsync = useAsync;
exports.useAsyncEffect = useAsyncEffect;

var React = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("react"));

var _latest = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/require("@react-hook/latest"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _ref(prev, action) {
  return {
    // This is the current status of the promise or async/await function. A
    // promise or async/await can only be in one state at a time.
    status: action.status,
    // The value is persisted between 'success' statuses. This means I can
    // still display things that depend on my current value while my new
    // value is loading.
    value: action.status === 'success' ? action.value : prev.value,
    // Errors get reset each time we leave the error state. There's really
    // no use in keeping those around. They go stale once we leave.
    error: action.status === 'error' ? action.error : void 0
  };
}

function _ref2() {
  return {
    status: 'idle',
    value: void 0,
    error: void 0
  };
}

function useAsync(asyncCallback) {
  const [state, dispatch] = React.useReducer(_ref, void 0, _ref2); // Creates a stable callback that manages our loading/success/error status updates
  // as the callback is invoked.

  const storedCallback = (0, _latest.default)(asyncCallback);
  const [callback] = React.useState(() => {
    const cancelled = new Set();
    let previous;
    return Object.assign(async (...args) => {
      // Reloading automatically cancels previous promises
      cancelled.add(previous);
      dispatch({
        status: 'loading'
      });
      let current = null;

      try {
        previous = current = storedCallback.current(...args);
        const value = await current;
        !cancelled.has(current) && dispatch({
          status: 'success',
          value
        });
      } catch (error) {
        current && !cancelled.has(current) && dispatch({
          status: 'error',
          error
        });
      } finally {
        cancelled.delete(current);
      }
    }, {
      cancel: () => {
        cancelled.add(previous);
      }
    });
  }); // Cancels any pending async callbacks when the hook unmounts

  React.useEffect(() => callback.cancel, [callback]);

  function _ref3() {
    // Prevent the callback from dispatching
    callback.cancel(); // Create a new callback and set status to cancelled

    dispatch({
      status: 'cancelled'
    });
  }

  return [React.useMemo(() => {
    return {
      status: state.status,
      value: state.value,
      error: state.error,
      cancel: _ref3
    };
  }, [callback, state]), callback];
}

function useAsyncEffect(asyncCallback, dependencies) {
  const [state, callback] = useAsync(asyncCallback); // Runs the callback each time deps change

  React.useEffect(() => {
    callback(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, dependencies);
  return state;
}