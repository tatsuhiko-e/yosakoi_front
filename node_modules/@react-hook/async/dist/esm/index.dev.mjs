import { useReducer, useState, useEffect, useMemo } from 'react';
import useLatest from '@react-hook/latest';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _ref(prev, action) {
  return {
    // This is the current status of the promise or async/await function. A
    // promise or async/await can only be in one state at a time.
    status: action.status,
    // The value is persisted between 'success' statuses. This means I can
    // still display things that depend on my current value while my new
    // value is loading.
    value: action.status === 'success' ? action.value : prev.value,
    // Errors get reset each time we leave the error state. There's really
    // no use in keeping those around. They go stale once we leave.
    error: action.status === 'error' ? action.error : void 0
  };
}

function _ref2() {
  return {
    status: 'idle',
    value: void 0,
    error: void 0
  };
}

function useAsync(asyncCallback) {
  var [state, dispatch] = useReducer(_ref, void 0, _ref2); // Creates a stable callback that manages our loading/success/error status updates
  // as the callback is invoked.

  var storedCallback = useLatest(asyncCallback);
  var [callback] = useState(() => {
    var cancelled = new Set();
    var previous;
    return Object.assign( /*#__PURE__*/_asyncToGenerator(function* () {
      // Reloading automatically cancels previous promises
      cancelled.add(previous);
      dispatch({
        status: 'loading'
      });
      var current = null;

      try {
        previous = current = storedCallback.current(...arguments);
        var value = yield current;
        !cancelled.has(current) && dispatch({
          status: 'success',
          value
        });
      } catch (error) {
        current && !cancelled.has(current) && dispatch({
          status: 'error',
          error
        });
      } finally {
        cancelled.delete(current);
      }
    }), {
      cancel: () => {
        cancelled.add(previous);
      }
    });
  }); // Cancels any pending async callbacks when the hook unmounts

  useEffect(() => callback.cancel, [callback]);

  function _cancel() {
    // Prevent the callback from dispatching
    callback.cancel(); // Create a new callback and set status to cancelled

    dispatch({
      status: 'cancelled'
    });
  }

  return [useMemo(() => {
    return {
      status: state.status,
      value: state.value,
      error: state.error,
      cancel: _cancel
    };
  }, [callback, state]), callback];
}
function useAsyncEffect(asyncCallback, dependencies) {
  var [state, callback] = useAsync(asyncCallback); // Runs the callback each time deps change

  useEffect(() => {
    callback(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, dependencies);
  return state;
}

export { useAsync, useAsyncEffect };
//# sourceMappingURL=index.dev.mjs.map
